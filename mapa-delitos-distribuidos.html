<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="UTF-8">
  <title>Mapa de Delitos - CTM El Risco</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
  <style>
    body {
      margin: 0;
      padding: 0;
    }

    #map {
      height: 100vh;
      width: 100%;
    }

    .leyenda {
      padding: 10px;
      background: white;
      border-radius: 5px;
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
      max-height: 80vh;
      overflow-y: auto;
      width: 300px;
    }

    .leyenda h4 {
      margin: 0 0 10px;
      font-size: 16px;
    }

    .leyenda-item {
      display: flex;
      align-items: center;
      margin-bottom: 5px;
    }

    .color-box {
      width: 15px;
      height: 15px;
      margin-right: 8px;
      border-radius: 50%;
    }

    .total-delitos {
      position: absolute;
      top: 10px;
      right: 10px;
      background: white;
      padding: 10px;
      border-radius: 5px;
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
      z-index: 1000;
      font-weight: bold;
    }

    .controles {
      position: absolute;
      top: 10px;
      left: 50px;
      background: white;
      padding: 10px;
      border-radius: 5px;
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
      z-index: 1000;
    }
  </style>
</head>

<body>
  <div id="map"></div>
  <div class="total-delitos" id="total-delitos"></div>
  <div class="controles">
    <button id="btn-centrar">Centrar Mapa</button>
  </div>

  <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
  <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
  <script>
    // Inicializar el mapa
    const map = L.map('map').setView([19.510, -99.096], 15);

    // Mapa base
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);

    // Polígono real de CTM El Risco
    const poligonoElRisco = {
      "type": "Feature",
      "geometry": {
        "type": "Polygon",
        "coordinates": [[
          [-99.09740966399839, 19.51266487533441],
          [-99.10056001114475, 19.51184350019888],
          [-99.1006093896991, 19.511303564087626],
          [-99.09965400636638, 19.509148468250586],
          [-99.09932498626866, 19.509227827856975],
          [-99.098853531969, 19.509016322113567],
          [-99.09863095442408, 19.509346968554595],
          [-99.0981457328141, 19.509095591825343],
          [-99.09843057741668, 19.508495805177503],
          [-99.09604558848774, 19.50725339452788],
          [-99.09533437072858, 19.5074291381071],
          [-99.09286947300322, 19.506017748674992],
          [-99.09259666715131, 19.505876914674985],
          [-99.09040664577094, 19.5095740415083],
          [-99.09493725520933, 19.51130173772033],
          [-99.09740966399839, 19.51266487533441]
        ]]
      }
    };

    // Añadir el polígono al mapa
    const poligonoLayer = L.geoJSON(poligonoElRisco, {
      style: {
        color: 'blue',
        fillOpacity: 0.1
      }
    }).addTo(map);

    // Ajustar la vista al polígono
    map.fitBounds(poligonoLayer.getBounds());

    // Delitos
    const delitos = [
      { nombre: "Violencia Familiar", cantidad: 31 },
      { nombre: "Robo", cantidad: 19 },
      { nombre: "Amenazas", cantidad: 12 },
      { nombre: "Daño A La Propiedad", cantidad: 7 },
      { nombre: "Fraude", cantidad: 6 },
      { nombre: "Usurpación", cantidad: 4 },
      { nombre: "Abuso De Autoridad", cantidad: 3 },
      { nombre: "Tentativa", cantidad: 3 },
      { nombre: "Electorales", cantidad: 2 },
      { nombre: "Lesiones Culposas", cantidad: 2 },
      { nombre: "Despojo", cantidad: 2 },
      { nombre: "Allanamiento", cantidad: 1 },
      { nombre: "Contra La Intimidad Sexual", cantidad: 1 },
      { nombre: "Corrupción De Menores", cantidad: 1 },
      { nombre: "Encubrimiento", cantidad: 1 },
      { nombre: "Ambiental", cantidad: 1 },
      { nombre: "Narcomenudeo", cantidad: 1 }
    ];

    // Colores para los delitos
    const colores = [
      '#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00',
      '#ffff33', '#a65628', '#f781bf', '#999999', '#66c2a5',
      '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854', '#ffd92f',
      '#e5c494', '#b3b3b3'
    ];

    // Ordenar delitos por cantidad (de mayor a menor)
    delitos.sort((a, b) => b.cantidad - a.cantidad);

    // Calcular el total de delitos
    const totalDelitos = delitos.reduce((sum, delito) => sum + delito.cantidad, 0);
    document.getElementById('total-delitos').innerText = `Total de delitos: ${totalDelitos}`;

    // Calcular el centro del polígono
    const turfPolygon = turf.polygon(poligonoElRisco.geometry.coordinates);
    const centro = turf.centroid(turfPolygon);
    const centroCoordenadas = [centro.geometry.coordinates[1], centro.geometry.coordinates[0]]; // Leaflet usa [lat, lng]

    console.log('Centro del polígono:', centroCoordenadas);

    // Calcular el área del polígono para determinar tamaños óptimos
    const areaPoligono = turf.area(turfPolygon); // Área en metros cuadrados
    const areaPoligonoKm2 = areaPoligono / 1000000; // Convertir a km²

    console.log(`Área del polígono: ${areaPoligono.toFixed(0)} m² (${areaPoligonoKm2.toFixed(3)} km²)`);

    // Calcular tamaños de círculo basados en el área del polígono
    // Queremos que los círculos cubran aproximadamente el 90% del área total (buen equilibrio)
    const factorCobertura = 0.9;
    const areaObjetivo = areaPoligono * factorCobertura;
    const areaPromedioPorCirculo = areaObjetivo / delitos.length;
    const radioPromedio = Math.sqrt(areaPromedioPorCirculo / Math.PI);

    console.log(`Radio promedio calculado: ${radioPromedio.toFixed(1)} metros`);

    // Crear leyenda
    const leyenda = L.control({ position: 'bottomleft' });
    leyenda.onAdd = function () {
      const div = L.DomUtil.create('div', 'leyenda');
      div.innerHTML = '<h4>Tipos de Delitos</h4>';

      delitos.forEach((delito, i) => {
        const porcentaje = ((delito.cantidad / totalDelitos) * 100).toFixed(1);
        div.innerHTML += `
          <div class="leyenda-item">
            <div class="color-box" style="background: ${colores[i % colores.length]}"></div>
            <span>${delito.nombre} (${delito.cantidad}) - ${porcentaje}%</span>
          </div>
        `;
      });

      return div;
    };
    leyenda.addTo(map);

    // Distribuir círculos por todo el polígono para maximizar cobertura
    function distribuirCirculos() {
      const bbox = turf.bbox(turfPolygon);
      const [minX, minY, maxX, maxY] = bbox;

      // Calcular dimensiones del polígono
      const anchoPoligono = maxX - minX;
      const altoPoligono = maxY - minY;

      // Determinar el número de filas y columnas para una distribución óptima
      const numDelitos = delitos.length;
      const aspectRatio = anchoPoligono / altoPoligono;

      // Calcular filas y columnas basado en el aspect ratio
      let filas = Math.ceil(Math.sqrt(numDelitos / aspectRatio));
      let columnas = Math.ceil(numDelitos / filas);

      // Ajustar si es necesario
      while (filas * columnas < numDelitos) {
        if (columnas * aspectRatio < filas) {
          columnas++;
        } else {
          filas++;
        }
      }

      console.log(`Distribuyendo en ${filas} filas y ${columnas} columnas`);

      // Calcular distancias mínimas basadas en el radio promedio
      const distanciaMinimaDensa = radioPromedio * 0.15; // Separación moderada
      const distanciaMinimaAleatoria = radioPromedio * 0.1; // Poca separación

      // Generar puntos candidatos en una grilla
      const puntosCandidatos = [];
      const espaciadoX = anchoPoligono / (columnas + 1);
      const espaciadoY = altoPoligono / (filas + 1);

      for (let fila = 1; fila <= filas; fila++) {
        for (let col = 1; col <= columnas; col++) {
          const x = minX + col * espaciadoX;
          const y = minY + fila * espaciadoY;

          // Añadir algo de variación aleatoria para evitar patrones demasiado rígidos
          const variacionX = (Math.random() - 0.5) * espaciadoX * 0.3;
          const variacionY = (Math.random() - 0.5) * espaciadoY * 0.3;

          const punto = turf.point([x + variacionX, y + variacionY]);

          // Verificar si el punto está dentro del polígono
          if (turf.booleanPointInPolygon(punto, turfPolygon)) {
            puntosCandidatos.push(punto);
          }
        }
      }

      console.log(`Puntos candidatos generados: ${puntosCandidatos.length}`);

      // Si no tenemos suficientes puntos, generar más con una grilla más densa
      if (puntosCandidatos.length < numDelitos) {
        console.log('Generando puntos adicionales con grilla más densa...');

        // Aumentar la densidad de la grilla
        const filasDensas = filas * 2;
        const columnasDensas = columnas * 2;
        const espaciadoXDenso = anchoPoligono / (columnasDensas + 1);
        const espaciadoYDenso = altoPoligono / (filasDensas + 1);

        for (let fila = 1; fila <= filasDensas; fila++) {
          for (let col = 1; col <= columnasDensas; col++) {
            const x = minX + col * espaciadoXDenso;
            const y = minY + fila * espaciadoYDenso;

            const punto = turf.point([x, y]);

            if (turf.booleanPointInPolygon(punto, turfPolygon)) {
              // Verificar que no esté muy cerca de puntos existentes
              const muyProximo = puntosCandidatos.some(p => {
                const distancia = turf.distance(punto, p, { units: 'meters' });
                return distancia < distanciaMinimaDensa;
              });

              if (!muyProximo) {
                puntosCandidatos.push(punto);
              }
            }
          }
        }
      }

      // Si aún no tenemos suficientes puntos, generar algunos aleatorios
      while (puntosCandidatos.length < numDelitos) {
        console.log('Generando puntos aleatorios adicionales...');

        for (let intento = 0; intento < 100 && puntosCandidatos.length < numDelitos; intento++) {
          const x = minX + Math.random() * anchoPoligono;
          const y = minY + Math.random() * altoPoligono;
          const punto = turf.point([x, y]);

          if (turf.booleanPointInPolygon(punto, turfPolygon)) {
            // Verificar distancia mínima
            const muyProximo = puntosCandidatos.some(p => {
              const distancia = turf.distance(punto, p, { units: 'meters' });
              return distancia < distanciaMinimaAleatoria;
            });

            if (!muyProximo) {
              puntosCandidatos.push(punto);
            }
          }
        }
      }

      // Seleccionar los mejores puntos para maximizar la distribución
      const puntosSeleccionados = [];

      if (puntosCandidatos.length <= numDelitos) {
        puntosSeleccionados.push(...puntosCandidatos);
      } else {
        // Algoritmo greedy para seleccionar puntos que maximicen la distancia entre ellos
        puntosSeleccionados.push(puntosCandidatos[0]);

        while (puntosSeleccionados.length < numDelitos) {
          let mejorPunto = null;
          let mejorDistanciaMinima = 0;

          for (const candidato of puntosCandidatos) {
            if (puntosSeleccionados.includes(candidato)) continue;

            // Calcular la distancia mínima a los puntos ya seleccionados
            const distanciaMinima = Math.min(...puntosSeleccionados.map(p =>
              turf.distance(candidato, p, { units: 'meters' })
            ));

            if (distanciaMinima > mejorDistanciaMinima) {
              mejorDistanciaMinima = distanciaMinima;
              mejorPunto = candidato;
            }
          }

          if (mejorPunto) {
            puntosSeleccionados.push(mejorPunto);
          } else {
            // Si no encontramos un punto óptimo, tomar el siguiente disponible
            const siguientePunto = puntosCandidatos.find(p => !puntosSeleccionados.includes(p));
            if (siguientePunto) {
              puntosSeleccionados.push(siguientePunto);
            }
          }
        }
      }

      console.log(`Puntos finales seleccionados: ${puntosSeleccionados.length}`);
      return puntosSeleccionados;
    }

    // Obtener puntos distribuidos
    const puntosDistribuidos = distribuirCirculos();

    // Asignar un punto a cada delito, empezando por los más grandes
    delitos.forEach((delito, i) => {
      if (i < puntosDistribuidos.length) {
        const punto = puntosDistribuidos[i];
        const coordenadas = [punto.geometry.coordinates[1], punto.geometry.coordinates[0]]; // Leaflet usa [lat, lng]

        // Calcular la distancia mínima al borde del polígono para determinar el radio máximo seguro
        const puntoTurf = turf.point(punto.geometry.coordinates);
        const bordePoligono = turf.polygonToLine(turfPolygon);
        const distanciaAlBorde = turf.pointToLineDistance(puntoTurf, bordePoligono, { units: 'meters' });

        // Calcular el radio basado en el porcentaje de delitos y el área del polígono
        const porcentajeDelito = (delito.cantidad / totalDelitos) * 100;

        // Usar radios equilibrados basados en el área
        const radioBase = radioPromedio * 0.7; // Radio mínimo (70% del promedio)
        const radioMaxTeórico = radioPromedio * 2.0; // Radio máximo (200% del promedio)

        // Calcular radio directamente proporcional al porcentaje
        const porcentajeMaximo = (delitos[0].cantidad / totalDelitos) * 100;
        const factorPorcentaje = porcentajeDelito / porcentajeMaximo;
        const radioCalculado = radioBase + factorPorcentaje * (radioMaxTeórico - radioBase);

        // Ser mucho más permisivo con la limitación - priorizar el tamaño sobre mantenerse dentro
        let radio = radioCalculado;
        // Solo limitar en casos extremos donde el círculo sería más grande que la mitad del polígono
        if (radioCalculado > radioPromedio * 3) {
          radio = radioPromedio * 3;
        }

        console.log(`Delito: ${delito.nombre}, Porcentaje: ${porcentajeDelito.toFixed(1)}%, Radio calculado: ${radioCalculado.toFixed(1)}m, Distancia al borde: ${distanciaAlBorde.toFixed(1)}m, Radio final: ${radio.toFixed(1)}m`);

        // Crear el círculo
        L.circle(coordenadas, {
          radius: radio,
          color: colores[i % colores.length],
          fillColor: colores[i % colores.length],
          fillOpacity: 0.6,
          weight: 2,
          opacity: 0.8
        }).bindPopup(`<strong>${delito.nombre}</strong><br>${delito.cantidad} casos (${((delito.cantidad / totalDelitos) * 100).toFixed(1)}%)<br>Radio: ${radio.toFixed(1)}m`)
          .addTo(map);
      }
    });

    // Botón para centrar el mapa
    document.getElementById('btn-centrar').addEventListener('click', function () {
      map.fitBounds(poligonoLayer.getBounds());
    });
  </script>
</body>

</html>